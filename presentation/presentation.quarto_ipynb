{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Introduction to Julia workshop\"\n",
        "# subtitle: \"How I Learned To Stop Worrying and Love Programming.\"\n",
        "format: \n",
        "    julia-revealjs:\n",
        "        slide-number: true\n",
        "        logo: figures/api_logo_big_black.png\n",
        "        footer: API January 2025\n",
        "        transition: none\n",
        "jupyter: julia-1.11\n",
        "execute: \n",
        "  cache: true\n",
        "---\n",
        "\n",
        "\n",
        "# The Julia programming language\n",
        "\n",
        "![](figures/Julia_(programming_language)_logo.png){width=5%  fig-align=\"center\"}\n",
        "\n",
        "## In a nutshell\n",
        "A dynamic, general-purpose programming language designed to be both accessible and fast.\n",
        "\n",
        "## In a nutshell\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Born at MIT in 2009, first release in 2011.\n",
        "    - Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Idea: A technical language that is both fast, and easy to develop.\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Version 1.0 released in 2018\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Still very actively developed, current version ~~v1.10.5~~ v1.11\n",
        ":::\n",
        "\n",
        "\n",
        "## Core features\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Inherently fast and easy to optimize \n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Built-in package manager and general registry\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Virtual environments\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Intuitive and math-like syntax\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Composable: seperate parts work together\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Free and open source\n",
        ":::\n",
        "\n",
        "## Other features\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.column width=\"45%\"}\n",
        "- Easy parallelism (including GPU)\n",
        "- GPU accelerated plotting\n",
        "- Call C and Fortran functions natively\n",
        "- Easy to call Python code\n",
        "- Automatic differentiation\n",
        ":::\n",
        "\n",
        "::: {.column width=\"45%\"}\n",
        "- Automically generate efficient, specialized code\n",
        "- Metaprogramming - code that returns code\n",
        "- Unicode support\n",
        "- Automated memory management\n",
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "# Julia lets you do prototyping, deployment, and analysis all in one.\n",
        "\n",
        "# Julia's performance\n",
        "\n",
        "## Microbenchmarks\n",
        "\n",
        "![](figures/benchmarks.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## Other benchmarks {.scrollable}\n",
        "::: {.incremental}\n",
        "- DataFrames.jl vs. pandas\n",
        "    - Consistently 10x, 20x, up to 100x faster on various tasks ([Database-like ops benchmark](https://duckdblabs.github.io/db-benchmark/))\n",
        "- DifferentialEquations.jl\n",
        "    - Outperforms Matlab, SciPy, Sundials, deSolve ![](figures/diffeq_benchmarks.png)\n",
        "        - [The SciML Benchmarks](https://docs.sciml.ai/SciMLBenchmarksOutput/stable/MultiLanguage/ode_wrapper_packages/#ODE-Solver-Multi-Language-Wrapper-Package-Work-Precision-Benchmarks-(MATLAB,-SciPy,-Julia,-deSolve-(R)))\n",
        ":::\n",
        "\n",
        "## Consequence {.smaller}\n",
        "\n",
        "- Easy to write your own code that is fast and accessible. \n",
        "- Packages do not need to rely on interfacing into languages like C and Fortran.\n",
        "- No black box of mixed languages.\n",
        "    - Julia all the way down\n",
        "\n",
        "![](figures/alwayshasbeen.png){fig-align=\"center\"}\n",
        "\n",
        "## Examples\n",
        "\n",
        "::: {.incremental}\n",
        "- Numpy: ![](figures/numpy.png){width=50%}\n",
        "- Scipy: ![](figures/scipy.png){width=50%}\n",
        "- Astropy: ![](figures/astropy.png){width=50%}\n",
        "- OrdinaryDiffEq.jl, Turing.jl, Syzygy.jl, Optimization.jl ![](figures/diffeq-turing-syzygy.png){width=50% fig-align=\"center\"}\n",
        ":::\n",
        "\n",
        "## How is Julia\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Julia is a JIT (**J**ust **I**n **T**ime)-compiled language\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Dynamically typed, with option to declare types\n",
        ":::\n",
        "\n",
        "::: {.fragment .fade-in-then-semi-out}\n",
        "- Interactive\n",
        ":::\n",
        "\n",
        "\n",
        "## What does Julia look like?\n",
        "\n",
        "##"
      ],
      "id": "ef8c4a4d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "using LinearAlgebra\n",
        "using Unitful: Unitful, Mass, Length, Velocity, @u_str\n",
        "using Unitful.DefaultSymbols: kg, m, s, km, J\n",
        "using UnitfulAstro\n",
        "\n",
        "const G = 6.674e-11m^3/kg/s^2\n",
        "\n",
        "struct Star{L <: Length, V <: Velocity}\n",
        "    mass::Mass\n",
        "    position::Vector{L}\n",
        "    velocity::Vector{V}\n",
        "end\n",
        "\n",
        "kinetic_energy(s::Star) = s.mass*(s.velocity ⋅ s.velocity)/2\n",
        "\n",
        "function potential_energy(star1::Star, star2::Star)\n",
        "    m₁ = star1.mass\n",
        "    m₂ = star2.mass\n",
        "    r = norm(star1.position - star2.position)\n",
        "    return -G*m₁*m₂/r\n",
        "end;"
      ],
      "id": "6cde3e38",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##\n",
        "\n",
        "```{.julia code-line-numbers=\"1-4|6|8-12|14|16-21\"}\n",
        "using LinearAlgebra\n",
        "using Unitful: Unitful, Mass, Length, Velocity, @u_str\n",
        "using Unitful.DefaultSymbols: kg, m, s, km, J\n",
        "using UnitfulAstro\n",
        "\n",
        "const G = 6.674e-11m^3/kg/s^2\n",
        "\n",
        "struct Star{L <: Length, V <: Velocity}\n",
        "    mass::Mass\n",
        "    position::Vector{L}\n",
        "    velocity::Vector{V}\n",
        "end\n",
        "\n",
        "kinetic_energy(s::Star) = s.mass*(s.velocity ⋅ s.velocity)/2\n",
        "\n",
        "function potential_energy(star1::Star, star2::Star)\n",
        "    m₁ = star1.mass\n",
        "    m₂ = star2.mass\n",
        "    r = norm(star1.position - star2.position)\n",
        "    return -G*m₁*m₂/r\n",
        "end\n",
        "```\n",
        "\n",
        "##\n"
      ],
      "id": "59f35fb4"
    },
    {
      "cell_type": "code",
      "metadata": {
        "output-location": "fragment"
      },
      "source": [
        "#| echo: true\n",
        "#| code-line-numbers: 3-9|11|12|14-18\n",
        "\n",
        "erg = u\"erg\"\n",
        "\n",
        "star1 = Star(1.0u\"Msun\",\n",
        "             [1.0,  0.0]u\"Rsun\", \n",
        "             [0.0, -5.0]u\"km/s\")\n",
        "             \n",
        "star2 = Star(2.0u\"Msun\", \n",
        "             [-0.5, 0.0]u\"Rsun\", \n",
        "             [ 0.0, 3.0]u\"km/s\")\n",
        "\n",
        "T = kinetic_energy(star1)\n",
        "U = potential_energy(star1, star2)\n",
        "\n",
        "@show T\n",
        "@show U\n",
        "\n",
        "@show erg(T)\n",
        "@show erg(U);"
      ],
      "id": "b6d9c74d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Multiple dispatch\n",
        "\n",
        "## A simple example\n"
      ],
      "id": "edf6bb45"
    },
    {
      "cell_type": "code",
      "metadata": {
        "output-location": "fragment"
      },
      "source": [
        "#| echo: true\n",
        "\n",
        "struct Dog end\n",
        "struct Cat end\n",
        "\n",
        "speak(d::Dog) = println(\"Woof!\")\n",
        "speak(c::Cat) = println(\"Meow!\")\n",
        "\n",
        "animals = [Dog(), Cat()]\n",
        "\n",
        "for animal in animals\n",
        "    speak(animal)\n",
        "end"
      ],
      "id": "c2d05e19",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## A better example\n"
      ],
      "id": "c1031f38"
    },
    {
      "cell_type": "code",
      "metadata": {
        "output-location": "fragment"
      },
      "source": [
        "#| echo: true\n",
        "#| code-line-numbers: 1|3|5|7|9|11|13\n",
        "\n",
        "using Measurements, OrdinaryDiffEqTsit5\n",
        "\n",
        "f(u, p, t) = p[1]*u\n",
        "\n",
        "u0 = 0.5 ± 0.0\n",
        "\n",
        "tspan = (0.0 ± 0.0, 1.0 ± 0.0)\n",
        "\n",
        "p = [1.01 ± 0.01]\n",
        "\n",
        "prob = ODEProblem(f, u0, tspan, p)\n",
        "\n",
        "sol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)"
      ],
      "id": "618ec58a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# What's bad about Julia?\n",
        "\n",
        "## What's bad about Julia? {.smaller}\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.incremental .column width=\"60%\"}\n",
        "- Startup latency\n",
        "    - Time To First X (TTFX)\n",
        "        - Getting better every year\n",
        "- Easy to learn, hard to master (like baking bread!)\n",
        "    - Many new concepts, eg. multiple dispatch, metaprogramming\n",
        "- ~~No small binaries~~\n",
        "    - This is now possible.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](figures/ttfdx.png)\n",
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "## Okay I'm intriged...\n",
        "\n",
        "... but I don't want to re-write all my spaghetti code!!\n",
        "\n",
        ". . .\n",
        "\n",
        "Fair point! But a few things to note:\n",
        "\n",
        "::: {.incremental}\n",
        "- Julia gets you 90% of the way with 10% of the effort\n",
        "- You can easily call Python code in Julia\n",
        "    - So start with all Python and gradually swap out parts\n",
        ":::\n",
        "\n",
        "# Thank you!\n",
        "\n",
        "Questions?\n",
        "\n",
        "## Resources\n",
        "\n",
        "- [The offical Julia website](https://julialang.org/)\n",
        "- [Astronomy packages for Julia](https://juliaastro.org/dev/index.html)\n",
        "- [Julia workflows: best practices](https://modernjuliaworkflows.org/)\n",
        "- [The official Julia documentation](https://docs.julialang.org/en/v1/)\n",
        "- [The Julia discourse](discourse.julialang.org)\n",
        "- [The Julia slack](julialang.slack.com)\n",
        "- [CUDA in Julia](https://cuda.juliagpu.org/stable/)\n",
        "- [Julia on HPC](https://github.com/JuliaParallel/JUHPC)\n",
        "\n",
        "# Extra slides\n",
        "\n",
        "## CUDA\n",
        "\n",
        "```{.julia}\n",
        "using CUDA\n",
        "\n",
        "N = 1e6\n",
        "A = CUDA.fill(1.0f0, N)\n",
        "B = CUDA.fill(1.0f0, N)\n",
        "\n",
        "C = A .+ B\n",
        "```\n",
        "\n",
        "## Stellar evolution\n",
        "\n",
        "```{.julia}\n",
        "abstract type StellarType\n",
        "struct MainSequence <: StellarType end\n",
        "struct RedGiant     <: StellarType end\n",
        "\n",
        "struct Star{T, tT <: StellarType}\n",
        "    M::T\n",
        "    L::T\n",
        "    R::T\n",
        "    stellar_type::tT\n",
        "end\n",
        "    \n",
        "\n",
        "function stellar_winds(star::Star{T, tT}) where tT <: MainSequence\n",
        "    return a_wind_prescription(star.M)\n",
        "end\n",
        "\n",
        "function stellar_winds(star::Star{T, tT}) where tT <: RedGiant\n",
        "    return a_different_wind_prescription(star.M, star.L)\n",
        "end\n",
        "```\n",
        "\n",
        "## N-body collision\n",
        "\n",
        "```{.julia}\n",
        "abstract type StellarType\n",
        "struct MainSequence <: StellarType end\n",
        "struct BlackHole     <: StellarType end\n",
        "\n",
        "struct Star{T, tT <: StellarType}\n",
        "    M::T\n",
        "    L::T\n",
        "    R::T\n",
        "    stellar_type::tT\n",
        "end\n",
        "    \n",
        "check_collision(body1::Star{T, tT <: MainSequence}, body2::Star{T, tT <: MainSequence}) = ...\n",
        "check_collision(body1::Star{T, tT <: MainSequence}, body2::Star{T, tT <: BlackHole})    = ...\n",
        "check_collision(body1::Star{T, tT <: BlackHole},    body2::Star{T, tT <: BlackHole})    = ...\n",
        "```\n",
        "\n",
        "## Unicode\n",
        "\n",
        "![](figures/pn1.png){width=60%}\n",
        "\n",
        "\n",
        "```{.julia}\n",
        "r̄ = r̄₁ - r̄₂\n",
        "v̄ = v̄₁ - v̄₂\n",
        "r = norm(r̄) # r₁₂\n",
        "r⁻¹ = 1/r\n",
        "n = r̄*r⁻¹\n",
        "v₁v₂ = dot(v̄₁, v̄₂) \n",
        "nv₁ = dot(n, v̄₁)\n",
        "nv₂ = dot(n, v̄₂)\n",
        "Gr⁻¹ = G*r⁻¹\n",
        "Gr⁻² = Gr⁻¹*r⁻¹\n",
        "\n",
        "# PN-1 acceleration\n",
        "ai = @. n*(Gr⁻²*m₂)*(5*Gr⁻¹*m₁ + 4*Gr⁻¹*m₂ + 3/2*nv₂^2 - v₁² + 4*v₁v₂ - 2*v₂²) +\n",
        "        (4*nv₁ - 3*nv₂)*v̄\n",
        "```\n"
      ],
      "id": "045e5447"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.3",
      "path": "/home/cwbruenech/.local/share/jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}